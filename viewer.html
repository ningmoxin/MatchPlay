<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>è§€çœ‹é…å° - MatchPlay</title>
  <link rel="stylesheet" href="css/style.css">
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;500;700&display=swap" rel="stylesheet">
  <style>
    /* è§€çœ‹é å°ˆç”¨æ¨£å¼ */
    .viewer-container {
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    .main-display {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 20px;
    }

    .reveal-animation {
      text-align: center;
    }

    .slot-machine {
      background: rgba(255, 255, 255, 0.95);
      border-radius: 24px;
      padding: 40px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
      margin-bottom: 30px;
    }

    .slot-display {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 15px;
      flex-wrap: wrap;
    }

    .slot-item {
      background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
      border-radius: 16px;
      padding: 25px 35px;
      min-width: 140px;
      font-size: 1.8rem;
      font-weight: 700;
      color: #333;
      box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);
      transition: all 0.3s;
    }

    .slot-item.revealed {
      background: linear-gradient(135deg, #c8e6c9 0%, #a5d6a7 100%);
      color: #1b5e20;
      animation: popIn 0.5s ease;
    }

    .slot-arrow {
      font-size: 2.5rem;
      color: #c41e3a;
    }

    .rolling-text {
      animation: textRoll 0.08s linear infinite;
    }

    @keyframes textRoll {
      0% { opacity: 1; }
      50% { opacity: 0.5; }
      100% { opacity: 1; }
    }

    .pair-number {
      font-size: 1.2rem;
      color: #666;
      margin-bottom: 20px;
    }

    .celebration {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      pointer-events: none;
      z-index: 100;
    }

    .confetti {
      position: absolute;
      width: 10px;
      height: 10px;
      animation: confettiFall 3s linear forwards;
    }

    @keyframes confettiFall {
      0% {
        transform: translateY(-10px) rotate(0deg);
        opacity: 1;
      }
      100% {
        transform: translateY(100vh) rotate(720deg);
        opacity: 0;
      }
    }

    .history-section {
      background: rgba(255, 255, 255, 0.1);
      padding: 20px;
      max-height: 200px;
      overflow-y: auto;
    }

    .history-section h3 {
      text-align: center;
      margin-bottom: 15px;
      font-size: 1rem;
    }

    .history-list {
      list-style: none;
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 10px;
    }

    .history-item {
      background: rgba(255, 255, 255, 0.2);
      padding: 8px 16px;
      border-radius: 20px;
      font-size: 0.9rem;
    }

    .waiting-screen {
      text-align: center;
    }

    .waiting-icon {
      font-size: 5rem;
      margin-bottom: 20px;
      animation: bounce 1.5s infinite;
    }

    .waiting-text {
      font-size: 1.5rem;
      margin-bottom: 10px;
    }

    .waiting-subtext {
      opacity: 0.7;
      font-size: 1rem;
    }

    .finished-screen {
      text-align: center;
    }

    .finished-icon {
      font-size: 5rem;
      margin-bottom: 20px;
    }

    .finished-text {
      font-size: 1.8rem;
      margin-bottom: 30px;
    }

    .all-pairs {
      background: rgba(255, 255, 255, 0.95);
      border-radius: 20px;
      padding: 30px;
      max-width: 500px;
      margin: 0 auto;
      color: #333;
    }

    .all-pairs h3 {
      margin-bottom: 20px;
      color: #165b33;
    }

    .all-pairs-list {
      list-style: none;
    }

    .all-pairs-item {
      padding: 12px;
      border-bottom: 1px solid #eee;
      font-size: 1.1rem;
    }

    .all-pairs-item:last-child {
      border-bottom: none;
    }

    .all-pairs-item .arrow {
      color: #c41e3a;
      margin: 0 10px;
    }
  </style>
</head>
<body>
  <div class="viewer-container">
    <!-- å°èˆª -->
    <nav class="nav-bar">
      <a href="index.html">â† è¿”å›é¦–é </a>
      <span>é…å°æ­æ›‰</span>
      <span id="connection-status">ğŸŸ¢ é€£ç·šä¸­</span>
    </nav>

    <!-- ä¸»é¡¯ç¤ºå€ -->
    <div class="main-display">
      <!-- ç­‰å¾…ç•«é¢ -->
      <div id="waiting-screen" class="waiting-screen">
        <div class="waiting-icon">ğŸ„</div>
        <div class="waiting-text">ç­‰å¾…é…å°é–‹å§‹...</div>
        <div class="waiting-subtext">ç®¡ç†è€…æ­£åœ¨æº–å‚™ä¸­</div>
      </div>

      <!-- æ­æ›‰å‹•ç•« -->
      <div id="reveal-screen" class="reveal-animation hidden">
        <div id="pair-number" class="pair-number">ç¬¬ 1 çµ„</div>
        <div class="slot-machine">
          <div class="slot-display" id="slot-display">
            <div id="slot-1" class="slot-item">ï¼Ÿï¼Ÿï¼Ÿ</div>
            <div class="slot-arrow">â†”</div>
            <div id="slot-2" class="slot-item">ï¼Ÿï¼Ÿï¼Ÿ</div>
            <div id="slot-arrow-3" class="slot-arrow hidden">â†”</div>
            <div id="slot-3" class="slot-item hidden">ï¼Ÿï¼Ÿï¼Ÿ</div>
          </div>
        </div>
        <div id="reveal-status" style="font-size: 1.2rem; opacity: 0.8;">
          ç­‰å¾…æ­æ›‰...
        </div>
      </div>

      <!-- å®Œæˆç•«é¢ -->
      <div id="finished-screen" class="finished-screen hidden">
        <div class="finished-icon">ğŸ‰</div>
        <div class="finished-text">é…å°æ­æ›‰å®Œç•¢ï¼</div>
        <div class="all-pairs">
          <h3>ğŸ æ‰€æœ‰é…å°çµæœ</h3>
          <ul id="all-pairs-list" class="all-pairs-list">
            <!-- å‹•æ…‹è¼‰å…¥ -->
          </ul>
        </div>
      </div>
    </div>

    <!-- å·²æ­æ›‰æ­·å² -->
    <div id="history-section" class="history-section hidden">
      <h3>âœ… å·²æ­æ›‰é…å°</h3>
      <ul id="history-list" class="history-list">
        <!-- å‹•æ…‹è¼‰å…¥ -->
      </ul>
    </div>

    <!-- æ…¶ç¥ç‰¹æ•ˆå®¹å™¨ -->
    <div id="celebration" class="celebration"></div>
  </div>

  <!-- Firebase SDK -->
  <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-database.js"></script>

  <!-- å…±ç”¨è¨­å®š -->
  <script src="js/firebase-config.js"></script>

  <script>
    // ç‹€æ…‹
    let currentGameState = { status: 'waiting', currentPairIndex: 0 };
    let currentPairs = [];
    let lastRevealedIndex = -1;
    let isAnimating = false;

    // å‹•ç•«è¨­å®šï¼ˆå¾ Firebase è®€å–ï¼‰
    let animationSettings = {
      rollCount: 15,    // åå­—æ»¾å‹•æ¬¡æ•¸
      revealDelay: 1    // æ­æ›‰é–“éš”ï¼ˆç§’ï¼‰
    };

    // DOM å…ƒç´ 
    const waitingScreen = document.getElementById('waiting-screen');
    const revealScreen = document.getElementById('reveal-screen');
    const finishedScreen = document.getElementById('finished-screen');
    const historySection = document.getElementById('history-section');

    const pairNumber = document.getElementById('pair-number');
    const slot1 = document.getElementById('slot-1');
    const slot2 = document.getElementById('slot-2');
    const slot3 = document.getElementById('slot-3');
    const slotArrow3 = document.getElementById('slot-arrow-3');
    const revealStatus = document.getElementById('reveal-status');

    const historyList = document.getElementById('history-list');
    const allPairsList = document.getElementById('all-pairs-list');
    const celebration = document.getElementById('celebration');

    // è–èª•åœ–æ¡ˆåº«ï¼ˆç”¨æ–¼æ»¾å‹•å‹•ç•«ï¼‰
    const christmasIcons = ['ğŸ…', 'ğŸ„', 'â­', 'ğŸ', 'â„ï¸', 'ğŸ¦Œ', 'ğŸ””', 'ğŸ•¯ï¸', 'ğŸ¤¶', 'â›„', 'ğŸ§¦', 'ğŸª', 'ğŸ¥›', 'âœ¨', 'ğŸ€', 'ğŸŒŸ', 'â„', 'ğŸŠ', 'ğŸ§£', 'ğŸ¿'];

    // éŸ³æ•ˆï¼ˆä½¿ç”¨ Web Audio API ç”¢ç”Ÿ - è–èª•æ­¡æ¨‚é¢¨æ ¼ï¼‰
    let audioContext = null;

    function initAudio() {
      if (!audioContext) {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
      }
      return audioContext;
    }

    // æ’­æ”¾æ»¾å‹•éŸ³æ•ˆï¼ˆæ¯æ¬¡åå­—åˆ‡æ›çš„å®å™¹è²ï¼‰
    let rollSoundIndex = 0;
    const rollNotes = [523.25, 587.33, 659.25, 698.46, 783.99, 880.00, 987.77, 1046.50]; // C5 åˆ° C6 éŸ³éš

    function playRollSound() {
      try {
        const ctx = initAudio();

        // ä½¿ç”¨éŸ³éšå¾ªç’°ï¼Œè®“è²éŸ³æ›´æœ‰æ—‹å¾‹æ„Ÿ
        const noteFreq = rollNotes[rollSoundIndex % rollNotes.length];
        rollSoundIndex++;

        const osc = ctx.createOscillator();
        const gainNode = ctx.createGain();

        osc.connect(gainNode);
        gainNode.connect(ctx.destination);

        osc.frequency.value = noteFreq;
        osc.type = 'sine';

        // çŸ­ä¿ƒæ¸…è„†çš„éŸ³æ•ˆ
        gainNode.gain.setValueAtTime(0.12, ctx.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.08);

        osc.start(ctx.currentTime);
        osc.stop(ctx.currentTime + 0.1);
      } catch (e) {}
    }

    // æ’­æ”¾æ­æ›‰éŸ³æ•ˆï¼ˆè–èª•éˆ´è² + é­”æ³•éŸ³æ•ˆï¼‰
    function playRevealSound() {
      try {
        const ctx = initAudio();

        // Jingle Bells é¢¨æ ¼çš„ä¸Šå‡éŸ³éš
        const notes = [
          { freq: 659.25, delay: 0 },      // E5
          { freq: 783.99, delay: 0.08 },   // G5
          { freq: 880.00, delay: 0.16 },   // A5
          { freq: 1046.50, delay: 0.24 },  // C6
          { freq: 1318.51, delay: 0.32 }   // E6
        ];

        notes.forEach(note => {
          // ä¸»éŸ³
          const osc1 = ctx.createOscillator();
          const osc2 = ctx.createOscillator();
          const gainNode = ctx.createGain();

          osc1.connect(gainNode);
          osc2.connect(gainNode);
          gainNode.connect(ctx.destination);

          osc1.frequency.value = note.freq;
          osc2.frequency.value = note.freq * 2; // å…«åº¦æ³›éŸ³
          osc1.type = 'sine';
          osc2.type = 'triangle';

          const startTime = ctx.currentTime + note.delay;
          gainNode.gain.setValueAtTime(0.15, startTime);
          gainNode.gain.exponentialRampToValueAtTime(0.01, startTime + 0.2);

          osc1.start(startTime);
          osc2.start(startTime);
          osc1.stop(startTime + 0.25);
          osc2.stop(startTime + 0.25);
        });

        // åŠ å…¥é–ƒäº®çš„é­”æ³•éŸ³æ•ˆ
        setTimeout(() => {
          const sparkle = ctx.createOscillator();
          const sparkleGain = ctx.createGain();
          sparkle.connect(sparkleGain);
          sparkleGain.connect(ctx.destination);
          sparkle.frequency.value = 2500;
          sparkle.type = 'sine';
          sparkleGain.gain.setValueAtTime(0.05, ctx.currentTime);
          sparkleGain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.3);
          sparkle.start(ctx.currentTime);
          sparkle.stop(ctx.currentTime + 0.3);
        }, 350);

      } catch (e) {}
    }

    // æ’­æ”¾æ…¶ç¥éŸ³æ•ˆï¼ˆè–èª•æ­¡æ¨‚æ—‹å¾‹ - We Wish You a Merry Christmas é¢¨æ ¼ï¼‰
    function playCelebrationSound() {
      try {
        const ctx = initAudio();

        // æ­¡æ¨‚çš„è–èª•æ—‹å¾‹ç‰‡æ®µ
        const melody = [
          { freq: 392.00, delay: 0, duration: 0.15 },      // G4
          { freq: 523.25, delay: 0.15, duration: 0.15 },   // C5
          { freq: 523.25, delay: 0.30, duration: 0.1 },    // C5
          { freq: 587.33, delay: 0.40, duration: 0.1 },    // D5
          { freq: 523.25, delay: 0.50, duration: 0.1 },    // C5
          { freq: 493.88, delay: 0.60, duration: 0.1 },    // B4
          { freq: 440.00, delay: 0.70, duration: 0.2 },    // A4
          { freq: 440.00, delay: 0.90, duration: 0.2 },    // A4
        ];

        melody.forEach(note => {
          const osc1 = ctx.createOscillator();
          const osc2 = ctx.createOscillator();
          const osc3 = ctx.createOscillator();
          const gainNode = ctx.createGain();

          osc1.connect(gainNode);
          osc2.connect(gainNode);
          osc3.connect(gainNode);
          gainNode.connect(ctx.destination);

          // è±å¯Œçš„å’Œè²
          osc1.frequency.value = note.freq;
          osc2.frequency.value = note.freq * 1.5; // äº”åº¦å’Œè²
          osc3.frequency.value = note.freq * 2;   // å…«åº¦
          osc1.type = 'sine';
          osc2.type = 'triangle';
          osc3.type = 'sine';

          const startTime = ctx.currentTime + note.delay;
          gainNode.gain.setValueAtTime(0.12, startTime);
          gainNode.gain.exponentialRampToValueAtTime(0.01, startTime + note.duration + 0.1);

          osc1.start(startTime);
          osc2.start(startTime);
          osc3.start(startTime);
          osc1.stop(startTime + note.duration + 0.15);
          osc2.stop(startTime + note.duration + 0.15);
          osc3.stop(startTime + note.duration + 0.15);
        });

        // çµå°¾çš„éˆ´éºè²
        setTimeout(() => {
          for (let i = 0; i < 5; i++) {
            setTimeout(() => {
              const bell = ctx.createOscillator();
              const bellGain = ctx.createGain();
              bell.connect(bellGain);
              bellGain.connect(ctx.destination);
              bell.frequency.value = 2000 + Math.random() * 1000;
              bell.type = 'sine';
              bellGain.gain.setValueAtTime(0.06, ctx.currentTime);
              bellGain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.2);
              bell.start(ctx.currentTime);
              bell.stop(ctx.currentTime + 0.2);
            }, i * 80);
          }
        }, 1100);

      } catch (e) {}
    }

    // === ç•«é¢åˆ‡æ› ===
    function showScreen(screen) {
      waitingScreen.classList.add('hidden');
      revealScreen.classList.add('hidden');
      finishedScreen.classList.add('hidden');
      historySection.classList.add('hidden');

      switch (screen) {
        case 'waiting':
          waitingScreen.classList.remove('hidden');
          break;
        case 'revealing':
          revealScreen.classList.remove('hidden');
          historySection.classList.remove('hidden');
          break;
        case 'finished':
          finishedScreen.classList.remove('hidden');
          break;
      }
    }

    // === éŠæˆ²ç‹€æ…‹è™•ç† ===
    function handleGameStateChange(state) {
      currentGameState = state;

      switch (state.status) {
        case 'waiting':
          showScreen('waiting');
          lastRevealedIndex = -1;
          break;

        case 'revealing':
          showScreen('revealing');
          checkForNewReveal();
          break;

        case 'finished':
          // ä¿æŒåœ¨æ­æ›‰ç•«é¢ï¼Œé¡¯ç¤ºæœ€å¾Œçš„é…å°çµæœ
          showScreen('revealing');
          // å¦‚æœæ­£åœ¨æ’­æ”¾å‹•ç•«ï¼Œç­‰å‹•ç•«çµæŸå¾Œé¡¯ç¤ºå®Œæˆè¨Šæ¯
          if (!isAnimating) {
            revealStatus.textContent = 'ğŸ‰ æ‰€æœ‰é…å°æ­æ›‰å®Œç•¢ï¼ğŸ‰';
            launchCelebration();
          }
          break;

        default:
          showScreen('waiting');
      }
    }

    // === é…å°è™•ç† ===
    function handlePairsChange(pairs) {
      currentPairs = pairs;

      if (currentGameState.status === 'revealing') {
        checkForNewReveal();
      }

      if (currentGameState.status === 'finished') {
        renderAllPairs();
      }

      renderHistory();
    }

    function checkForNewReveal() {
      const revealedPairs = currentPairs.filter(p => p.revealed);
      const newRevealedIndex = revealedPairs.length - 1;

      if (newRevealedIndex > lastRevealedIndex && !isAnimating) {
        const newPair = revealedPairs[revealedPairs.length - 1];
        if (newPair) {
          playRevealAnimation(newPair, newRevealedIndex + 1);
          lastRevealedIndex = newRevealedIndex;
        }
      } else if (revealedPairs.length === 0) {
        // å°šæœªæ­æ›‰ä»»ä½•é…å°
        pairNumber.textContent = `ç¬¬ 1 çµ„ / å…± ${currentPairs.length} çµ„`;
        slot1.textContent = 'ï¼Ÿï¼Ÿï¼Ÿ';
        slot2.textContent = 'ï¼Ÿï¼Ÿï¼Ÿ';
        slot3.textContent = 'ï¼Ÿï¼Ÿï¼Ÿ';
        slot1.classList.remove('revealed');
        slot2.classList.remove('revealed');
        slot3.classList.remove('revealed');
        slot3.classList.add('hidden');
        slotArrow3.classList.add('hidden');
        revealStatus.textContent = 'ç­‰å¾…æ­æ›‰...';
      }
    }

    // === æ­æ›‰å‹•ç•«ï¼ˆé€ä¸€æ­æ›‰ï¼‰ ===
    async function playRevealAnimation(pair, pairIndex) {
      isAnimating = true;

      const isTriple = pair.isTriple;
      const pairLabel = isTriple ? `ç¬¬ ${pairIndex} çµ„ (ä¸‰äºº) / å…± ${currentPairs.length} çµ„` : `ç¬¬ ${pairIndex} çµ„ / å…± ${currentPairs.length} çµ„`;
      pairNumber.textContent = pairLabel;
      revealStatus.textContent = 'æ­æ›‰ç¬¬ä¸€ä½...';

      // é‡ç½®æ¨£å¼
      slot1.classList.remove('revealed');
      slot2.classList.remove('revealed');
      slot3.classList.remove('revealed');
      slot1.textContent = 'ï¼Ÿï¼Ÿï¼Ÿ';
      slot2.textContent = 'ï¼Ÿï¼Ÿï¼Ÿ';
      slot3.textContent = 'ï¼Ÿï¼Ÿï¼Ÿ';

      // é¡¯ç¤º/éš±è—ç¬¬ä¸‰å€‹ slot
      if (isTriple) {
        slot3.classList.remove('hidden');
        slotArrow3.classList.remove('hidden');
      } else {
        slot3.classList.add('hidden');
        slotArrow3.classList.add('hidden');
      }

      const rollCount = animationSettings.rollCount;
      const revealDelay = animationSettings.revealDelay * 1000;

      // é€ä¸€æ­æ›‰æ¯å€‹äºº
      // ç¬¬ä¸€äºº
      await revealSlot(slot1, pair.person1Name, rollCount);
      launchMiniCelebration();

      if (isTriple) {
        revealStatus.textContent = 'æ­æ›‰ç¬¬äºŒä½...';
      } else {
        revealStatus.textContent = 'æ­æ›‰é…å°å°è±¡...';
      }

      await delay(revealDelay);

      // ç¬¬äºŒäºº
      await revealSlot(slot2, pair.person2Name, rollCount);
      launchMiniCelebration();

      // ç¬¬ä¸‰äººï¼ˆå¦‚æœæ˜¯ä¸‰äººçµ„ï¼‰
      if (isTriple) {
        revealStatus.textContent = 'æ­æ›‰ç¬¬ä¸‰ä½...';
        await delay(revealDelay);
        await revealSlot(slot3, pair.person3Name, rollCount);
        launchMiniCelebration();
      }

      revealStatus.textContent = isTriple ? 'ä¸‰äººé…å°æˆåŠŸï¼ğŸ‰' : 'é…å°æˆåŠŸï¼ğŸ‰';

      // æ’­æ”¾æ…¶ç¥éŸ³æ•ˆ
      playCelebrationSound();

      // æ¨™è¨˜å‹•ç•«å®Œæˆï¼Œè®“å…¶ä»–é é¢å¯ä»¥é¡¯ç¤ºçµæœ
      await database.ref('pairs').child(pair.id).update({ animationComplete: true });

      isAnimating = false;

      // æª¢æŸ¥æ˜¯å¦ç‚ºæœ€å¾Œä¸€çµ„ï¼ˆéŠæˆ²å·²çµæŸï¼‰
      if (currentGameState.status === 'finished') {
        // å»¶é²ä¸€ä¸‹å†é¡¯ç¤ºå®Œæˆè¨Šæ¯
        await delay(1500);
        revealStatus.textContent = 'ğŸ‰ æ‰€æœ‰é…å°æ­æ›‰å®Œç•¢ï¼ğŸ‰';
        launchCelebration();
      }
    }

    // å–®ä¸€ slot çš„æ»¾å‹•æ­æ›‰
    function revealSlot(slotElement, finalName, totalRolls) {
      return new Promise((resolve) => {
        // æ»¾å‹•é€Ÿåº¦ï¼šé–‹å§‹å¿«ï¼ŒçµæŸæ…¢ï¼ˆæ¼¸æ…¢æ•ˆæœï¼‰
        let rollCount = 0;

        // é‡ç½®éŸ³éšç´¢å¼•
        rollSoundIndex = 0;

        slotElement.classList.add('rolling-text');

        function doRoll() {
          // è¨ˆç®—ç•¶å‰é–“éš”æ™‚é–“ï¼ˆè¶Šä¾†è¶Šæ…¢ï¼‰
          const progress = rollCount / totalRolls;
          // å¾ 100ms æ¼¸è®Šåˆ° 250msï¼ˆè®“è²éŸ³æ›´æ¸…æ™°ï¼‰
          const currentInterval = 100 + (progress * progress * 180);

          slotElement.textContent = getRandomDisplayName();
          rollCount++;

          // æ¯æ¬¡åå­—åˆ‡æ›éƒ½æ’­æ”¾éŸ³æ•ˆ
          playRollSound();

          if (rollCount >= totalRolls) {
            slotElement.classList.remove('rolling-text');
            slotElement.textContent = formatFinalName(finalName);
            slotElement.classList.add('revealed');

            // æ’­æ”¾æ­æ›‰éŸ³æ•ˆ
            playRevealSound();

            resolve();
          } else {
            setTimeout(doRoll, currentInterval);
          }
        }

        // é–‹å§‹æ»¾å‹•
        doRoll();
      });
    }

    // å»¶é²å‡½å¼
    function delay(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }

    // å–å¾—éš¨æ©Ÿåœ–æ¡ˆ
    function getRandomIcon() {
      return christmasIcons[Math.floor(Math.random() * christmasIcons.length)];
    }

    // å–å¾—éš¨æ©Ÿé¡¯ç¤ºå…§å®¹ï¼ˆåœ–æ¡ˆ + åå­—ï¼‰
    function getRandomDisplayName() {
      const icon = getRandomIcon();
      if (currentPairs.length > 0) {
        const allNames = [];
        currentPairs.forEach(p => {
          allNames.push(p.person1Name, p.person2Name);
          if (p.person3Name) {
            allNames.push(p.person3Name);
          }
        });
        const randomName = allNames[Math.floor(Math.random() * allNames.length)];
        return icon + ' ' + randomName;
      }
      return icon + ' ???';
    }

    // æ ¼å¼åŒ–æœ€çµ‚åå­—ï¼ˆåŠ ä¸Šåœ–æ¡ˆï¼‰
    function formatFinalName(name) {
      const icon = getRandomIcon();
      return icon + ' ' + name;
    }

    // === æ­·å²è¨˜éŒ„ ===
    function renderHistory() {
      // åªé¡¯ç¤ºå‹•ç•«å·²å®Œæˆçš„é…å°
      const completedPairs = currentPairs.filter(p => p.animationComplete);

      if (completedPairs.length === 0) {
        historyList.innerHTML = '<li class="history-item" style="opacity: 0.5;">å°šç„¡æ­æ›‰</li>';
        return;
      }

      historyList.innerHTML = completedPairs.map((pair, index) => {
        if (pair.isTriple) {
          return `<li class="history-item">${index + 1}. ${escapeHtml(pair.person1Name)} â†” ${escapeHtml(pair.person2Name)} â†” ${escapeHtml(pair.person3Name)}</li>`;
        }
        return `<li class="history-item">${index + 1}. ${escapeHtml(pair.person1Name)} â†” ${escapeHtml(pair.person2Name)}</li>`;
      }).join('');
    }

    function renderAllPairs() {
      // åªé¡¯ç¤ºå‹•ç•«å·²å®Œæˆçš„é…å°
      const completedPairs = currentPairs.filter(p => p.animationComplete);

      if (completedPairs.length === 0) {
        allPairsList.innerHTML = '<li>ç„¡é…å°è³‡æ–™</li>';
        return;
      }

      allPairsList.innerHTML = completedPairs.map((pair, index) => {
        if (pair.isTriple) {
          return `<li class="all-pairs-item">${escapeHtml(pair.person1Name)} <span class="arrow">â†”</span> ${escapeHtml(pair.person2Name)} <span class="arrow">â†”</span> ${escapeHtml(pair.person3Name)}</li>`;
        }
        return `<li class="all-pairs-item">${escapeHtml(pair.person1Name)} <span class="arrow">â†”</span> ${escapeHtml(pair.person2Name)}</li>`;
      }).join('');
    }

    // === æ…¶ç¥æ•ˆæœ ===
    function launchMiniCelebration() {
      const colors = ['#c41e3a', '#165b33', '#f5b829', '#ff6b6b', '#4ecdc4'];

      for (let i = 0; i < 20; i++) {
        const confetti = document.createElement('div');
        confetti.className = 'confetti';
        confetti.style.left = Math.random() * 100 + '%';
        confetti.style.background = colors[Math.floor(Math.random() * colors.length)];
        confetti.style.animationDuration = (Math.random() * 2 + 1) + 's';
        confetti.style.animationDelay = Math.random() * 0.5 + 's';
        celebration.appendChild(confetti);

        setTimeout(() => confetti.remove(), 3000);
      }
    }

    function launchCelebration() {
      const colors = ['#c41e3a', '#165b33', '#f5b829', '#ff6b6b', '#4ecdc4', '#fff'];

      for (let i = 0; i < 100; i++) {
        const confetti = document.createElement('div');
        confetti.className = 'confetti';
        confetti.style.left = Math.random() * 100 + '%';
        confetti.style.background = colors[Math.floor(Math.random() * colors.length)];
        confetti.style.width = (Math.random() * 10 + 5) + 'px';
        confetti.style.height = (Math.random() * 10 + 5) + 'px';
        confetti.style.animationDuration = (Math.random() * 3 + 2) + 's';
        confetti.style.animationDelay = Math.random() * 2 + 's';
        celebration.appendChild(confetti);

        setTimeout(() => confetti.remove(), 5000);
      }
    }

    // === å·¥å…·å‡½å¼ ===
    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    // === åˆå§‹åŒ– ===
    document.addEventListener('DOMContentLoaded', function() {
      // é›ªèŠ±æ•ˆæœ
      createSnowflakes();

      // ç›£è½å‹•ç•«è¨­å®šè®ŠåŒ–
      database.ref('settings').on('value', (snapshot) => {
        const settings = snapshot.val();
        if (settings) {
          animationSettings.rollCount = settings.rollCount || 15;
          animationSettings.revealDelay = settings.revealDelay || 1;
          console.log('å‹•ç•«è¨­å®šå·²æ›´æ–°:', animationSettings);
        }
      });

      // ç›£è½éŠæˆ²ç‹€æ…‹
      onGameStateChange(handleGameStateChange);

      // ç›£è½é…å°è®ŠåŒ–
      onPairsChange(handlePairsChange);

      // é€£ç·šç‹€æ…‹ç›£æ¸¬
      database.ref('.info/connected').on('value', (snapshot) => {
        const connected = snapshot.val();
        const statusEl = document.getElementById('connection-status');
        statusEl.textContent = connected ? 'ğŸŸ¢ å·²é€£ç·š' : 'ğŸ”´ é›¢ç·š';
      });
    });
  </script>
</body>
</html>
